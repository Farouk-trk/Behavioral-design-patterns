In this video we are going to talk about the Observer Pattern. As described earlier, the Observer Pattern is used when we need many objects to receive a notification whenever another object signals a message.
An object called the subject or publisher, maintains a list of its dependents (called observers or subscribers) and notifies them automatically of any state changes by calling one of their methods (usually called update method).
In our example, we have two different electronics store divisions. The current price of items on both divisions depends on the value-added tax and the US dollar to euro exchange rate, hence the store division's objects need to be notified in two cases. Firstly, a notification is required whenever a change occurs in the finance object attribute due to a change of the value-added tax. Secondly, a notification is required whenever the US dollar to euro exchange rate is updated.
Let's get into the code:
We create a Subject Interface to handle adding, deleting and updating all the observers. In this interface we add three methods, register, unregister and notify-observer.
Next we create the Observer interface in which we add the method called "update". This method is called whenever the subject changes.
Now we create our concrete subject class Finance. Finance inherits from subject interface therefore we implement all the methods from the subject interface. Next, we define some attributes, first an arraylist to store all the observers in (here comes the need to import array list), then two private double fields that are going to represent the value-added tax and the US dollar to euro exchange rate. Then we need a constructor where we will define our array list. Now we move to our implemented method and start with the method called "register" which takes an observer object as a parameter and adds it to the observers' array list. Then we implement the method called "unregister" and again we pass as parameter an observer object. This method identifies the index of the observer object passed and removes it from our array list. This Observer is no longer subscribed to our subject. And then the notify Observer is going to cycle through all the subscribed observers and notifies each of them of any change in tax or exchange rate by calling the respective update method.  Now we create a couple of methods to change the tax and exchange rate and notify the observers after each change.
Next up we create our first concrete observer class Computers, the first division of our store.
It inherits from the Observer interface. We identify our attributes, namely the Dell computer primary price and HP laptop primary price which are constants. The current price of these two items is calculated depending on the tax and exchange rate values. We also create an attribute that holds a reference to the Finance object. Next, we create the constructor. It takes a reference to the current finance as parameter. We store the reference to the finance object so we can make calls to its methods, here we display a message of a creation of a new observer, and finally we add the observer to the Subjects ArrayList. Now we need to implement the update method inherited from the observer interface. This method is called to update the observer and takes as parameters the modified values of the value-added tax and US dolars to euro exchange rate. We update the current prices of the HP and Dell computers using the corresponding function parameters, and then we display the current prices.
We do the same work for the second concrete observer class which is called "accessories". Here, we define the primary price of two accessory items, called "mouse" and "keyboard", and again the current prices will be updated by calling the update method.
Finally, we create our main method, here we create an instance of the Subject class finance that will handle updating all observers, then we create the first concrete observer object computer and we pass the finance object as a parameter. Our observer now is subscribed in the subject, we do so for the second concrete object of the class accessories. We can play around with the values of the tax and exchange rate and see how the concrete observers would be notified and update their current prices.
