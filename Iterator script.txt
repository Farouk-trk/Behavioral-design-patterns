Iterating over items in a collection
In this tutorial we will cover the Iterator design pattern. As described earlier, the Iterator design Pattern provides a uniform way to iterate over items in a collection without any need to know its underlying representation.

In our example, We have two collections of cars, bmw cars and ford cars. The BMW cars are stored in an arrayList while the ford cars are stored in an Array. We want to create a uniform way to cycle through all cars independantly of the datastructure. Besides, we will create a special iterator that only returns the new cars that are registred after a defined year.

Let's get into the code:
Firs we create a class car. The Car class has two string attributes "brand" and "model" and an integer attribute "yearOfRegistration". We create a constractor that takes two strings and an integer as parameters and assign their values to our attributes.Next we create three getter methods to get the values of our attributes. Finally we create a method named getInfo that return a sting containing all the car's information.

Now we create the Aggregate interface called "Cars".It defines a common interface for all possible aggregates. Here we define a single method "getIterator".

Next up we create our first concrete Aggregate class "BmwCars".
It inherits from the "Cars" interface therefore we need to implement all the methods from the aggregate interface. We define our attribute bmwCars which is  an arraylist of cars objects (here comes the need to import array list). We create a method "AddCar" that alow us to add new cars to the bmwcars arraylist. This method take two strings and an integer as a paremeter, creates a new car object and stores it in our arraylist. Next, The method "getIterator" will return a new BmwIterator. We add new method "getNewIterator" wich take an integer as a parameter and return a new NewBmwIterator passing our arraylist bmwCars and the integer year as arguments.

We do the same work for the second concrete Aggregate class which is called "FordCars". Here, we define an array "fordCars" to store the cars objects. We create a constractor that cretaes an array of zero cars and assing it to our fordCars attribute. Then, we create the method addCar.This method takes as parameters the brand, the model and the yearOfRegestration values.It creates a new car object by passing its attributes as arguments.Then everytime we want to add the new car to our array we create a new array with a  of the same lenght of our array plus one(+1), we copy the element of our array in the new array and we add our new car in the end.finally we assign the value of the new array to our fordCars attribute.The getIterator method is the same of the "BmwCars" class.

Now we create the Aggregate iterator called "Cars". Here we define a two method.the method "HasNext()" that returns a boolean and the second method returns a Car object and named "Next()".

Next up, we create our first concrete Iterator and we name it "BmwIterator". We start by defining our attributes. Our first attibute cars is an arrayList of car objects,and we import ArrayList. Then Cursor of type integer. The constractor of this class takes an arrayList of car objects as a parameter, assign its value to "cars" attribute and assign the value of 0 to the cursor. Next, our implemented method hasNext return a boolean indicating if there is still other elements in the cars arrayList. Finally,the "next()" method return the car object of cursor index and increments the cursor.

We do the same work for the second concrete Iterator class which is called "FordIterator".The only difference here is that we use and array of cars insted of a list of cars.

We creta a thid iterator that iterate trough bmw cars that are registrated after a given year.We name it NewBmwIterator. In this class we have an extra integer attribute year.The constractor also has an extra integer parameter.We assign the value of the new parameter to our year attribute. The method has next now will check if there is still car objects in the arrayList that fulfill our condition.We check if there is still cars in the arraList, if yes we check if the registration year of the car object of cursor index is grater than the  year of condition, if yes we return true, if no we increment the cursor and return the HaseNext() method itself.In case there is no more objects in the arraList the method will return false.finally the "Nex()" method return the car object ind increments the cursor.

Now we are ready to create the main class to test the design pattern.
We start by creating a BmwCars object and then we add a bunch of cars by calling addCar method.We also create a FordCars object and we do the same adding some cars.Now, we create our first CarIterator by calling the getIterator method of our bmwCars object.Now we write a while loop to iterate through all the elements of the bmwCars object with the use of the itarator methods "hasNext()" and "next()". Similarly, we create a second CarIterator by calling the getIterator() method of the fordCars object.we rewrite the same loop using the new iterator methods and we can see that we get all the ford card displayed on the screen.As we can see, we get access to the element of our aggregate in the same way without knowing in wich datastructure their elements are stored. Now we can test our third concrete iterator.We creta a third CarIterator object by calling the getNewIterator method of the bmwCars object and we pass 2015 as an argument.In the same way, we can get access only the cars that are registrated after the year of 2015.

